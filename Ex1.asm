section .data
    main db '101tf11flb10001', 0 ; Исходная строка
    pattern db '10', 0           ; Шаблон для поиска
    patternEnd db '1', 0         ; Конец шаблона
    substring resb 256           ; Буфер для хранения найденной подстроки

section .text
    global _start

; Функция для вывода найденной подстроки
print_substring:
    mov eax, 4                   ; Системный вызов для sys_write
    mov ebx, 1                   ; Дескриптор файла stdout
    mov ecx, substring           ; Указатель на начало буфера подстроки
    mov edx, eax                 ; Длина строки для вывода
    int 0x80                     ; Вызов прерывания
    ret

_start:
    mov esi, main                ; Указатель на начало строки
    mov edi, pattern             ; Указатель на начало шаблона

next_char:
    cmp byte [esi], 0            ; Проверка на конец строки
    je end_of_string

    mov al, [esi]                ; Загрузка символа из строки
    cmp al, [edi]                ; Сравнение символа с первым символом шаблона
    jne not_matched              ; Если символы не совпадают, переход к следующему символу строки

    ; Найден первый символ шаблона, проверим второй символ
    mov al, [esi+1]              ; Загрузка следующего символа из строки
    cmp al, [edi+1]              ; Сравнение символа с вторым символом шаблона
    jne not_matched              ; Если символы не совпадают, переход к следующему символу строки

    ; Подстрока найдена, копируем ее в буфер и выводим
    mov ecx, substring           ; Указатель на начало буфера подстроки
    mov edi, esi                 ; Копируем адрес найденной подстроки в edi
    mov eax, edi                 ; Сохраняем адрес начала подстроки
    mov edx, 0                   ; Обнуляем счетчик длины подстроки

copy_substring:
    mov al, [edi]                ; Загрузка символа из найденной подстроки
    cmp al, 't'                  ; Проверка, является ли текущий символ 't'
    je replace_space             ; Если да, заменяем его на пробел
    mov [ecx], al                ; Копирование символа в буфер
    jmp continue_copy            ; Продолжаем копирование

replace_space:
    mov al, ' '                  ; Заменяем символ 't' на пробел
    mov [ecx], al                ; Копируем пробел в буфер

continue_copy:
    inc edi                      ; Переход к следующему символу найденной подстроки
    inc ecx                      ; Переход к следующему символу буфера
    inc edx                      ; Увеличение счетчика длины подстроки
    cmp al, 0                    ; Проверка на конец строки
    jne copy_substring           ; Если не конец строки, продолжаем копирование


    ; Выводим найденную подстроку
    mov ecx, eax                 ; Указатель на начало найденной подстроки
    mov edx, edx                 ; Длина найденной подстроки
    call print_substring         ; Вызов функции для вывода подстроки

    ; Переходим к символу после найденной подстроки
    add esi, edx

    ; Пропускаем символы до конца шаблона "1"
next_pattern_char:
    cmp byte [esi], 0            ; Проверка на конец строки
    je end_of_string
    cmp byte [esi], '1'          ; Проверка символа на конец шаблона
    je next_char                 ; Если символ '1', переходим к следующей итерации
    inc esi                      ; Иначе переходим к следующему символу строки
    jmp next_pattern_char        ; Проверяем следующий символ

not_matched:
    inc esi                      ; Переход к следующему символу строки
    jmp next_char                ; Продолжение поиска

end_of_string:
    ; Завершение программы
    mov eax, 60                  ; Системный вызов для sys_exit
    xor edi, edi                 ; Код завершения 0
    syscall
